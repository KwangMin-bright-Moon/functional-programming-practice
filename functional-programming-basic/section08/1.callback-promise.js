import { log } from '../utils';

// 콜백 패턴
function add10(a, callback) {
  setTimeout(() => callback(a + 10), 100);
}

add10(5, (res) => {
  log(res);
});

function add20(a) {
  return new Promise((resolve) => setTimeout(() => resolve(a + 20), 1000));
}

add20(5).then(log);

// add10과 add20이 다른 점은 add20은 프로미스를 return 한다는 것이다.

// 사용할 때 연속적인 부분에서 두 함수는 차이가 있다.
// add20은 체이닝을 통해 연속적으로 작성할 수 있다.

var a = add10(5, (res) => {
  add10(res, (res) => {
    add10(res, (res) => {
      // log(res);
    });
  });
});

var b = add20(5).then(add20).then(add20).then(add20).then(log);

// 프로미스와 콜백의 중요한 차이는 비동기 상황을 일급 값으로 다룬다는 점에서 차이가 있다.
// 프로미스는 프로미스 클래스를 통해 만들어진 인스턴스를 만환한다. 그 인스턴스는 대기와 실패를 다루는 일급값으로 이루어져있다.
// 코드와 컨텍스트로 다루는 것이 아니라 값으로 다룬다. 대기되어지고 있다라는 어떤 값을 만든다는 점에서 차이가 있다.

// 콜백 함수의 경우 비동기 상황이 코드로만 표현돼 있다.
// add20의 경우 비동기 상황에 대한 값을 만들어 리턴하고 있다는 점이 아주 중요한 차이이다.

// a와 b를 비교해보면 a는 undefined 이지만 b는 promise라는 값을 가진다.
// add10의 경우 리턴 값은 전혀 중요하지 않고 비동기 상황(setTimeout)이 일어난다는 코드적인 상황과
// 그것이 끝났을 때 다시 어떤 함수를 실행한다는 context만 남아있는 상황이다.
// 반면 add20의 경우 프로스미스가 반환 돼고 이후 그 값으로 내가 원하는 일들을 할 수 있다는 것이 중요한 차이이다.
// 추가적으로 내가 하고 싶은 일을 처리할 수 있다.
// 비동기로 일어난 상황에 대해서 값으로 다룰 수 있고 값으로 다룰 수 있다는 말은 일급이라는 말이다.
